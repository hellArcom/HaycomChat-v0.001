import socket
import threading
import ssl
import getpass      
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Protocol.KDF import scrypt
from Crypto.Util.Padding import pad, unpad
import base64
import socket
import threading
import os

HOST = '127.0.0.1'  # ip du serveur
PORT = 54424

try:
    # Cr√©ation du contexte SSL
    context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH, cafile="SSL/server.crt")  # catfile=endroit/du/ssl
    context.check_hostname = False  # desactiver la verif
    context.verify_mode = ssl.CERT_NONE  # desactiver la verif
except:
    print("Erreur lors de la cr√©ation du contexte SSL. (server.crt et surment manquant.)")

def login():
    # Utiliser return au lieu de exit() pour revenir au menu principal en cas d'erreur
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:
        try:
            client.connect((HOST, PORT))
            print("üîê Connexion au serveur en cours...")
            global secure_client
            secure_client = context.wrap_socket(client, server_hostname=HOST)
        except ConnectionRefusedError:
             print("‚ùå Connexion refus√©e. Le serveur est-il d√©marr√© et accessible?")
             input("Appuyez sur Entr√©e pour continuer...") # Pause pour voir le message
             return # Retourne au menu
        except Exception as e:
             print(f"‚ùå Erreur de connexion initiale: {e}")
             input("Appuyez sur Entr√©e pour continuer...")
             return # Retourne au menu

        # Authentification
        try:
            # --- MODIFICATION START ---
            # 1. Demander l'identifiant D'ABORD
            username = input("Identifiant : ")
            # 2. Envoyer l'identifiant
            secure_client.send(username.encode())

            # 3. Attendre le prompt du mot de passe (ou un message d'erreur initial comme IP_LOCKED)
            response = secure_client.recv(1024).decode()

            # G√©rer les erreurs potentielles re√ßues AVANT le prompt du mot de passe
            # Le serveur peut envoyer IP_LOCKED imm√©diatement s'il d√©tecte un blocage
            if response == "IP_LOCKED":
                print("‚ùå Votre IP est bloqu√©e. R√©essayez plus tard.")
                secure_client.close()
                input("Appuyez sur Entr√©e pour continuer...")
                return # Retourne au menu
            elif response != "MOT DE PASSE : ":
                # Si on ne re√ßoit pas le prompt attendu, il y a un probl√®me
                # Cela peut arriver si le serveur envoie AUTH_FAIL pour une autre raison
                # ou si le protocole est d√©synchronis√©.
                print(f"‚ùå R√©ponse inattendue du serveur apr√®s l'envoi de l'identifiant: {response}")
                secure_client.close()
                input("Appuyez sur Entr√©e pour continuer...")
                return # Retourne au menu

            # 4. Afficher le prompt re√ßu et demander le mot de passe
            print(response, end="") # Affiche "MOT DE PASSE : "
            password = getpass.getpass()
            # 5. Envoyer le mot de passe
            secure_client.send(password.encode())

            # 6. Recevoir la r√©ponse finale d'authentification
            auth_response = secure_client.recv(1024).decode()
            # --- MODIFICATION END ---

            if auth_response == "AUTH_FAIL":
                print("‚ùå Authentification √©chou√©e (Identifiant ou mot de passe incorrect)!")
            elif auth_response == "AUTH_SUCCESS":
                print("‚úÖ Authentification r√©ussie ! Vous pouvez maintenant discuter.")
                # Continuer vers le chat...
                cle_utilisateur = getpass.getpass("üîë Entrez votre cl√© de chiffrement : ")
                threading.Thread(target=receive_messages, args=(secure_client, cle_utilisateur), daemon=True).start()
                aff_menu(secure_client, username, cle_utilisateur)
                # Si aff_menu se termine (d√©connexion), la fonction login se termine aussi.
                return # Retourne au menu apr√®s d√©connexion normale
            elif auth_response == "IP_LOCKED": # Peut aussi √™tre re√ßu apr√®s √©checs r√©p√©t√©s
                 print("‚ùå Trop de tentatives √©chou√©es. Votre IP est bloqu√©e.")
            else:
                # G√©rer d'autres r√©ponses possibles (AUTH_TIMEOUT, etc.)
                print(f"‚ùå Erreur d'authentification inattendue: {auth_response}")

        except ssl.SSLError as e:
             print(f"‚ùå Erreur SSL: {e}. V√©rifiez les certificats ou la configuration SSL.")
        except ConnectionResetError:
             print("‚ùå La connexion a √©t√© r√©initialis√©e par le serveur pendant l'authentification.")
        except Exception as e:
            print(f"‚ùå Erreur pendant l'authentification : {e}")
        finally:
            # Assurer la fermeture propre du socket si ce n'est pas d√©j√† fait
            try:
                if secure_client.fileno() != -1: # V√©rifie si le socket est encore ouvert
                    secure_client.close()
            except Exception:
                pass # Ignore les erreurs lors de la fermeture

        # Si on arrive ici, c'est qu'il y a eu une erreur ou √©chec d'authentification
        input("Appuyez sur Entr√©e pour continuer...")
        return # Retourne au menu principal

def aes_encrypt(texte, cle_utilisateur):
    try:
        """Chiffre le texte avec AES en utilisant une cl√© d√©riv√©e"""
        salt = get_random_bytes(16)
        key = scrypt(cle_utilisateur.encode(), salt, key_len=32, N=2 ** 14, r=8, p=1)

        iv = get_random_bytes(16)
        cipher = AES.new(key, AES.MODE_CBC, iv)

        # Appliquer un padding PKCS7
        texte_padded = pad(texte.encode(), AES.block_size)

        encrypted_text = cipher.encrypt(texte_padded)

        return base64.b64encode(salt + iv + encrypted_text).decode()
    except:
        print("Erreur lors du chiffrement.")
        return None


def aes_decrypt(texte_chiffre, cle_utilisateur):
    try:
        """D√©chiffre le texte avec AES"""
        data = base64.b64decode(texte_chiffre)
        salt, iv, encrypted_text = data[:16], data[16:32], data[32:]

        key = scrypt(cle_utilisateur.encode(), salt, key_len=32, N=2 ** 14, r=8, p=1)
        cipher = AES.new(key, AES.MODE_CBC, iv)

        decrypted_text = cipher.decrypt(encrypted_text)

        # Retirer le padding PKCS7 proprement
        decrypted_text = unpad(decrypted_text, AES.block_size)

        return decrypted_text.decode()
    except:
        print("Erreur lors du d√©chiffrement.")
        return "‚ö†Ô∏è Impossible de d√©chiffrer le message re√ßu. Ignor√©. "


def receive_messages(client_socket, cle_session):
    while True:
        try:
            encrypted_message = client_socket.recv(1024).decode()
            if encrypted_message:
                if encrypted_message.startswith("MESSAGE_FROM:"):
                    parts = encrypted_message.split(":", 2)
                    if len(parts) == 3:
                        sender, content = parts[1], parts[2]
                        try:
                            decrypted_message = aes_decrypt(content, cle_session)
                            print(f"\nüì• Message de {sender} : {decrypted_message}\n> ", end="")
                        except:
                            print(f"\n‚ö†Ô∏è Impossible de d√©chiffrer le message re√ßu de {sender}. Ignor√©.\n> ", end="")
                    else:
                        print(f"\n‚ö†Ô∏è Message re√ßu dans un format invalide : {encrypted_message}\n> ", end="")
                else:
                    try:
                        decrypted_message = aes_decrypt(encrypted_message, cle_session)
                        print(f"\nüì• Message re√ßu : {decrypted_message}\n> ", end="")
                    except:
                        print(f"\n‚ö†Ô∏è Impossible de d√©chiffrer le message re√ßu. Ignor√©.\n> ", end="")
        except:
            print("‚ùå Connexion au serveur perdue.")
            break



def env_msg(secure_client, cle_utilisateur, username):
    try:
        while True:
            print("Entrer exit en tant que message pour quitter.")
            recipient = input("Destinataire (ou 'all' pour tous) : ")
            message = input("Message : ")
            if message.lower() == "exit":
                aff_menu(secure_client, username, cle_utilisateur)
                return
            if secure_client.fileno() == -1:
                print("Connexion perdue.")
                break
            if recipient.lower() == "all":
                message_to_send = aes_encrypt(message, cle_utilisateur) # Chiffrer le message sans le nom d'utilisateur
            else:
                message_to_send = f"SEND_TO:{recipient}:{aes_encrypt(message, cle_utilisateur)}" # Chiffrer le message
            try:
                secure_client.send(message_to_send.encode())
            except (ConnectionResetError, ssl.SSLError, ConnectionRefusedError) as e:
                print(f"Erreur de connexion: {e}")
                break
            except Exception as e:
                print(f"Erreur lors de l'envoi du message: {e}")
                secure_client.send(b"EXIT")  # Send exit signal before closing
                secure_client.shutdown(socket.SHUT_RDWR)
                secure_client.close()
                break
    except:
        print("Erreur avec la fonction d'envoie des message.")


def cree_compte():
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as client:
        client.connect((HOST, PORT))
        secure_client = context.wrap_socket(client, server_hostname=HOST)

        secure_client.send(b"CREATE_ACCOUNT")  # Indique au serveur qu'on veut cr√©er un compte

        username = input("Nom d'utilisateur : ")
        secure_client.send(username.encode())

        password = getpass.getpass("Mot de passe : ")
        secure_client.send(password.encode())

        response = secure_client.recv(1024).decode() # Wait for the response from the server
        if response == "ACCOUNT_CREATED":
            print("‚úÖ Compte cr√©√© avec succ√®s !")
        elif response == "USERNAME_TAKEN":
            print("‚ùå Ce nom d'utilisateur est d√©j√† pris.")
        else:
            print("‚ùå Erreur lors de la cr√©ation du compte.")
        
        secure_client.close() # close the connection after receiving the response.
        input("Appuyez sur Entr√©e pour continuer...")
        Start_menu()

# Fonction pour les menue
def clear_ecran():
    """Effacer le terminal en fonction de l'OS."""
    try:
        os.system('cls' if os.name == 'nt' else 'clear')
    except:
        print("Vous utiliser un os non compatible donc l'√©cran na pas pu √™tre effac√©.")


def aff_menu(secure_client, username, cle_utilisateur):
    clear_ecran()
    print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
    print("‚ïë       Menu Principal        ‚ïë")
    print("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£")
    print("‚ïë 1. Envoyez un message       ‚ïë")
    print("‚ïë 2. Cr√©er un groupe          ‚ïë")
    print("‚ïë 3. Ajouter un ami           ‚ïë")
    print("‚ïë 4. Bloquer un utilisateur   ‚ïë")
    print("‚ïë 5. Signaler                 ‚ïë")
    print("‚ïë 6. Quitter                  ‚ïë")
    print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    choix = input("Choisissez une option: ")
    if choix == '1':
        print(f"Vous avez choisit {choix} Le menue envoyez un message est affich√©")
        env_msg(secure_client, cle_utilisateur, username)  # Pass secure_client, username and cle_utilisateur
    elif choix == '2':
        print(f"Vous avez choisit {choix} Pour cr√©√© un groupe (option non disponible)")
        autre_menu(secure_client, username, cle_utilisateur)
    elif choix == '3':
        print(f"Vous avvez choisit {choix} Pour Ajouter un ami (vous avez pas d'ami) (option non disponible)")
        autre_menu(secure_client, username, cle_utilisateur)
    elif choix == '4':
        print(f"Vous avvez choisit {choix} pour bloquer un utilisateur (option non disponible)")
        autre_menu(secure_client, username, cle_utilisateur)
    elif choix == '5':
        print(f"Menue {choix} affich√© pour signaler (option non disponible)")
        autre_menu(secure_client, username, cle_utilisateur)
    elif choix == '6':
        print("Au revoir!")
        secure_client.send(b"EXIT")  # Envoyez les message de d√©connection aux serveur
        secure_client.shutdown(socket.SHUT_RDWR)  # Fermer la connection en lecture seul
    else:
        print("Option invalide.")
        input("Appuyez sur Entr√©e pour continuer...")
        aff_menu(secure_client, username, cle_utilisateur)


def autre_menu(secure_client, username, cle_utilisateur):
    clear_ecran()
    print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
    print("‚ïë Cette option n'est pas encore disponible ‚ïë")
    print("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£")
    print("‚ïë 1. HaycomChat est en cours de dev        ‚ïë")
    print("‚ïë 2. Donc pas tout est encore disponible   ‚ïë")
    print("‚ïë 3. Retour au menu principal              ‚ïë")
    print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    choix = input("  Choisissez une option: ")
    if choix == '1':
        print("Option 1 s√©lectionn√©e.")
        input("Appuyez sur Entr√©e pour continuer...")
        autre_menu(secure_client, username, cle_utilisateur)
    elif choix == '2':
        print("Option 2 s√©lectionn√©e.")
        input("Appuyez sur Entr√©e pour continuer...")
        autre_menu(secure_client, username, cle_utilisateur)
    elif choix == '3':
        aff_menu(secure_client, username, cle_utilisateur)
    else:
        print("Option invalide.")
        input("Appuyez sur Entr√©e pour continuer...")
        autre_menu(secure_client, username, cle_utilisateur)


def Start_menu():
    clear_ecran()
    print("‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó")
    print("‚ïë      Que voulais vous faire ?            ‚ïë")
    print("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£")
    print("‚ïë 1. Ce connecter                          ‚ïë")
    print("‚ïë 2. Cr√©√© un compte                        ‚ïë")
    print("‚ïë 3. Quitter                               ‚ïë")
    print("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù")
    choix = input("  Choisissez une option: ")
    if choix == '1':
        print("Ce conencter")
        input("Appuyez sur Entr√©e pour continuer...")
        login()
    elif choix == '2':
        print("cr√©√© un compte.")
        input("Appuyez sur Entr√©e pour continuer...")
        cree_compte()
    elif choix == '3':
        print("Vous avez choisit de fermer le programme.")
        exit()
    else:
        print("Option invalide.")
        input("Appuyez sur Entr√©e pour continuer...")
        Start_menu()

# Connexion au serveur avec gestion de la connexion SSL
try:
    Start_menu()  # menu de d√©part
except Exception as e:
    print(f"‚ùå Une erreur est survenue: ( {e} )")

print("‚ùå Connexion au serveur perdue.")
try:
    secure_client.close()
except:
    pass
input("Appuyez sur Entr√©e pour quitter...")
exit()
